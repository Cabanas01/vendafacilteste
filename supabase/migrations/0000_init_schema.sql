-- =============================================
-- 1. EXTENSIONS
-- =============================================
create extension if not exists "uuid-ossp";

-- =============================================
-- 2. TABLES
-- =============================================

-- Users Table: Stores public user data
create table users (
    id uuid references auth.users on delete cascade not null primary key,
    email text unique,
    name text,
    avatar_url text,
    is_admin boolean default false
);
comment on table public.users is 'Public profile information for each user.';

-- Stores Table: Represents a tenant in the system
create table stores (
    id uuid default gen_random_uuid() primary key,
    user_id uuid references public.users on delete set null, -- Store owner
    name text not null,
    cnpj text not null unique,
    legal_name text,
    logo_url text,
    address jsonb,
    phone text,
    timezone text default 'America/Sao_Paulo',
    settings jsonb default '{}'::jsonb,
    business_type text,
    status text default 'trial' not null,
    created_at timestamptz default now()
);
comment on table public.stores is 'Each row is a tenant, representing a single store or business.';

-- Store Members Table: Many-to-many relationship between users and stores
create table store_members (
    user_id uuid references public.users on delete cascade not null,
    store_id uuid references public.stores on delete cascade not null,
    role text check (role in ('admin', 'staff')) not null,
    primary key (user_id, store_id)
);
comment on table public.store_members is 'Associates users with stores and defines their roles.';

-- Products Table
create table products (
    id uuid default gen_random_uuid() primary key,
    store_id uuid references public.stores on delete cascade not null,
    name text not null,
    category text,
    price_cents integer not null check (price_cents >= 0),
    cost_cents integer check (cost_cents >= 0),
    stock_qty integer not null default 0,
    min_stock_qty integer,
    active boolean default true,
    barcode text,
    created_at timestamptz default now(),
    unique (store_id, barcode)
);
comment on table public.products is 'Stores product catalog and inventory for each store.';

-- Customers Table
create table customers (
    id uuid default gen_random_uuid() primary key,
    store_id uuid references public.stores on delete cascade not null,
    name text not null,
    email text,
    phone text,
    cpf text,
    created_at timestamptz default now()
);
comment on table public.customers is 'Stores customer information for each store.';

-- Sales Table
create table sales (
    id uuid primary key,
    store_id uuid references public.stores on delete cascade not null,
    created_at timestamptz default now(),
    total_cents integer not null,
    payment_method text check (payment_method in ('cash', 'pix', 'card')) not null
);
comment on table public.sales is 'Records each sale transaction.';

-- Sale Items Table
create table sale_items (
    id uuid default gen_random_uuid() primary key,
    sale_id uuid references public.sales on delete cascade not null,
    product_id uuid references public.products on delete set null,
    product_name_snapshot text not null,
    product_barcode_snapshot text,
    quantity integer not null,
    unit_price_cents integer not null,
    subtotal_cents integer not null
);
comment on table public.sale_items is 'Line items for each sale.';

-- Cash Registers Table
create table cash_registers (
    id text primary key,
    store_id uuid references public.stores on delete cascade not null,
    opened_at timestamptz not null,
    closed_at timestamptz,
    opening_amount_cents integer not null,
    closing_amount_cents integer
);
comment on table public.cash_registers is 'Records the opening and closing of cash registers.';

-- Store Access Table (Entitlements)
create table store_access (
    store_id uuid references public.stores on delete cascade not null primary key,
    plano_nome text,
    plano_tipo text check (plano_tipo in ('free', 'weekly', 'monthly', 'yearly', 'vitalicio')),
    data_inicio_acesso timestamptz,
    data_fim_acesso timestamptz,
    status_acesso text check (status_acesso in ('ativo', 'expirado', 'bloqueado', 'aguardando_liberacao')),
    origem text check (origem in ('hotmart', 'kiwify', 'perfectpay', 'admin', 'onboarding')),
    renovavel boolean default false,
    updated_at timestamptz default now()
);
comment on table public.store_access is 'Manages subscription and access entitlements for each store.';

-- Subscription Events Table (Tracking)
create table subscription_events (
    id bigint generated by default as identity primary key,
    created_at timestamptz default now(),
    provider text not null,
    event_type text not null,
    event_id text not null,
    store_id uuid,
    user_id uuid,
    plan_id text,
    status text,
    raw_payload jsonb,
    unique (event_id, provider)
);
comment on table public.subscription_events is 'Logs all incoming webhook events from payment providers for tracking and auditing.';

-- Admin Logs Table
create table admin_logs (
    id uuid default gen_random_uuid() primary key,
    admin_id uuid references public.users on delete set null,
    action text not null,
    entity text not null,
    entity_id text,
    created_at timestamptz default now()
);
comment on table public.admin_logs is 'Audits critical actions performed by administrators.';

-- Analytics: User Sessions Table
create table user_sessions (
    session_id uuid primary key,
    store_id uuid references public.stores on delete cascade not null,
    user_id uuid references public.users on delete cascade not null,
    user_agent text,
    ip inet,
    device_type text,
    started_at timestamptz default now(),
    last_seen_at timestamptz default now()
);
comment on table public.user_sessions is 'Tracks user sessions for analytics.';

-- Analytics: User Events Table
create table user_events (
    id uuid default gen_random_uuid() primary key,
    store_id uuid,
    user_id uuid,
    session_id uuid references public.user_sessions on delete set null,
    event_name text not null,
    event_group text,
    metadata jsonb,
    created_at timestamptz default now()
);
comment on table public.user_events is 'Logs specific user actions within the application for detailed analytics.';

create table unique_clicks (
    id bigint generated by default as identity primary key,
    store_id uuid not null,
    session_id uuid not null,
    target text not null,
    metadata jsonb,
    created_at timestamptz default now(),
    unique(store_id, session_id, target)
);
comment on table public.unique_clicks is 'Records unique clicks per session for analytics.';

-- =============================================
-- 3. TRIGGERS and FUNCTIONS
-- =============================================

-- Function to create a public user profile on new user signup
create or replace function public.handle_new_user()
returns trigger as $$
begin
  insert into public.users (id, email, name, avatar_url)
  values (new.id, new.email, new.raw_user_meta_data->>'full_name', new.raw_user_meta_data->>'avatar_url');
  return new;
end;
$$ language plpgsql security definer;

-- Trigger to call the function on new user creation in auth.users
create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();

-- Function to create a store and link the owner
create or replace function public.create_new_store(
    p_name text,
    p_legal_name text,
    p_cnpj text,
    p_address jsonb,
    p_phone text,
    p_timezone text
)
returns public.stores as $$
declare
    new_store public.stores;
begin
    -- Create the store
    insert into public.stores (user_id, name, legal_name, cnpj, address, phone, timezone)
    values (auth.uid(), p_name, p_legal_name, p_cnpj, p_address, p_phone, p_timezone)
    returning * into new_store;

    -- Add the owner as a store member with 'admin' role
    insert into public.store_members (user_id, store_id, role)
    values (auth.uid(), new_store.id, 'admin');

    return new_store;
end;
$$ language plpgsql security definer;

-- Function to delete a user's account and associated data
create or replace function public.delete_user_account()
returns void as $$
begin
    -- This function should cascade delete based on foreign keys.
    -- For example, deleting from stores will cascade to products, sales, etc.
    -- First, delete the user's owned stores, which will trigger cascades.
    delete from public.stores where user_id = auth.uid();
    
    -- Then, delete the user from the public.users table.
    delete from public.users where id = auth.uid();
    
    -- Finally, call the auth admin to delete the user from auth.users.
    -- This requires the `supabase_admin` role.
    -- perform delete from auth.users where id = auth.uid();
end;
$$ language plpgsql security definer;

-- Function to safely decrement product stock
create or replace function public.decrement_stock(p_product_id uuid, p_quantity int)
returns void as $$
begin
    update public.products
    set stock_qty = stock_qty - p_quantity
    where id = p_product_id;
end;
$$ language plpgsql;

-- Function to check a store's current subscription status
create or replace function public.get_store_access_status(p_store_id uuid)
returns table (
    acesso_liberado boolean,
    data_fim_acesso timestamptz,
    plano_nome text,
    mensagem text
) as $$
begin
    return query
    select
        case
            when sa.status_acesso = 'ativo' and sa.data_fim_acesso >= now() then true
            else false
        end as acesso_liberado,
        sa.data_fim_acesso,
        sa.plano_nome,
        case
            when sa.status_acesso = 'bloqueado' then 'Seu acesso foi bloqueado. Entre em contato com o suporte.'
            when sa.status_acesso = 'expirado' or sa.data_fim_acesso < now() then 'Seu plano expirou. Renove para continuar.'
            when sa.status_acesso = 'aguardando_liberacao' then 'Aguardando liberação do pagamento.'
            when sa.status_acesso = 'ativo' and sa.data_fim_acesso >= now() then 'Seu acesso está ativo até ' || to_char(sa.data_fim_acesso, 'DD/MM/YYYY') || '.'
            else 'Seu acesso está inativo. Escolha um plano para começar.'
        end as mensagem
    from store_access sa
    where sa.store_id = p_store_id;
end;
$$ language plpgsql;

-- Function for admin billing analytics
create or replace function get_billing_analytics(p_from timestamptz, p_to timestamptz)
returns table (
    total_revenue numeric,
    new_subscriptions bigint,
    cancellations bigint,
    revenue_by_provider jsonb,
    recent_events jsonb
)
language plpgsql
as $$
begin
    return query
    with events as (
        select * from subscription_events
        where created_at between p_from and p_to
    )
    select
        coalesce(sum((raw_payload->'data'->'purchase'->'price'->>'value')::numeric), 0) as total_revenue,
        (select count(*) from events where event_type = 'PURCHASE_APPROVED') as new_subscriptions,
        (select count(*) from events where event_type = 'SUBSCRIPTION_CANCELED') as cancellations,
        (
            select jsonb_agg(t)
            from (
                select
                    provider,
                    coalesce(sum((raw_payload->'data'->'purchase'->'price'->>'value')::numeric), 0) as total
                from events
                where event_type = 'PURCHASE_APPROVED'
                group by provider
            ) t
        ) as revenue_by_provider,
        (
            select jsonb_agg(e.*) from (
                select id, event_type, provider, created_at
                from events
                where event_type in ('PURCHASE_APPROVED', 'SUBSCRIPTION_CANCELED', 'ADMIN_GRANTED_PLAN')
                order by created_at desc
                limit 10
            ) e
        ) as recent_events;
end;
$$;


-- Function for user analytics summary
create or replace function get_analytics_summary(p_store_id uuid, p_from timestamptz, p_to timestamptz)
returns record
as $$
declare
  result record;
begin
  select
    count(case when event_name = 'profile_view' then 1 end) as total_profile_views,
    (select count(*) from unique_clicks uc where uc.store_id = p_store_id and uc.created_at between p_from and p_to) as total_unique_clicks,
    count(case when event_name = 'report_opened' then 1 end) as total_reports_opened,
    count(*) as total_events,
    (
        select jsonb_agg(t) from (
            select event_name, count(*) as count
            from user_events ue
            where ue.store_id = p_store_id and ue.created_at between p_from and p_to
            group by event_name
            order by count desc
            limit 5
        ) t
    ) as top_event_names,
    (
        select jsonb_agg(d) from (
            select date_trunc('day', created_at)::date as day, count(*)
            from user_events ue
            where ue.store_id = p_store_id and ue.created_at between p_from and p_to
            group by 1
            order by 1
        ) d
    ) as events_by_day
  into result
  from user_events
  where store_id = p_store_id and created_at between p_from and p_to;

  return result;
end;
$$ language plpgsql;


-- Function for unique click tracking
create or replace function rpc_register_unique_click(
    p_store_id uuid,
    p_session_id uuid,
    p_target text,
    p_metadata jsonb
)
returns void as $$
begin
    insert into public.unique_clicks(store_id, session_id, target, metadata)
    values (p_store_id, p_session_id, p_target, p_metadata)
    on conflict (store_id, session_id, target) do nothing;
end;
$$ language plpgsql;

-- =============================================
-- 4. ROW-LEVEL SECURITY (RLS)
-- =============================================

-- Enable RLS for all tables
alter table public.users enable row level security;
alter table public.stores enable row level security;
alter table public.store_members enable row level security;
alter table public.products enable row level security;
alter table public.customers enable row level security;
alter table public.sales enable row level security;
alter table public.sale_items enable row level security;
alter table public.cash_registers enable row level security;
alter table public.store_access enable row level security;
alter table public.subscription_events enable row level security;
alter table public.admin_logs enable row level security;
alter table public.user_sessions enable row level security;
alter table public.user_events enable row level security;
alter table public.unique_clicks enable row level security;


-- Helper function to get the current user's store ID
create or replace function get_my_store_id()
returns uuid as $$
declare
    store_id uuid;
begin
    select s.id into store_id
    from public.stores s
    where s.user_id = auth.uid()
    union
    select sm.store_id
    from public.store_members sm
    where sm.user_id = auth.uid()
    limit 1;
    return store_id;
end;
$$ language plpgsql;

-- Function to check if a user is an admin of their store
create or replace function is_store_admin(p_user_id uuid, p_store_id uuid)
returns boolean as $$
begin
    return exists (
        select 1 from store_members
        where user_id = p_user_id and store_id = p_store_id and role = 'admin'
    );
end;
$$ language plpgsql;

-- Policies for 'users'
create policy "Users can view their own profile" on public.users for select using (auth.uid() = id);
create policy "Users can update their own profile" on public.users for update using (auth.uid() = id);

-- Policies for 'stores'
create policy "Users can view their own store" on public.stores for select using (id = get_my_store_id());
create policy "Store admins can update their store" on public.stores for update using (is_store_admin(auth.uid(), id));

-- Policies for 'store_members'
create policy "Store members can view other members" on public.store_members for select using (store_id = get_my_store_id());
create policy "Store admins can manage members" on public.store_members for all using (is_store_admin(auth.uid(), store_id));

-- Policies for data tables (Products, Customers, Sales, Cash Registers)
create policy "Members can view their store data" on public.products for select using (store_id = get_my_store_id());
create policy "Members can manage their store data" on public.products for all using (store_id = get_my_store_id());

create policy "Members can view their store data" on public.customers for select using (store_id = get_my_store_id());
create policy "Members can manage their store data" on public.customers for all using (store_id = get_my_store_id());

create policy "Members can view their store data" on public.sales for select using (store_id = get_my_store_id());
create policy "Members can manage their store data" on public.sales for all using (store_id = get_my_store_id());

create policy "Members can view their store data" on public.sale_items for select using (sale_id in (select id from sales where store_id = get_my_store_id()));
create policy "Members can manage their store data" on public.sale_items for all using (sale_id in (select id from sales where store_id = get_my_store_id()));

create policy "Members can view their store data" on public.cash_registers for select using (store_id = get_my_store_id());
create policy "Members can manage their store data" on public.cash_registers for all using (store_id = get_my_store_id());

-- Policies for analytics tables
create policy "Members can manage their store's analytics" on public.user_sessions for all using (store_id = get_my_store_id());
create policy "Members can manage their store's analytics" on public.user_events for all using (store_id = get_my_store_id());
create policy "Members can manage their store's analytics" on public.unique_clicks for all using (store_id = get_my_store_id());

-- Policies for billing tables (more restrictive)
create policy "Users can view their own store access" on public.store_access for select using (store_id = get_my_store_id());
-- Note: Inserts/updates to store_access are handled by webhooks/admin actions with service_role.

-- Admin-only policies (admins bypass RLS, but these are good for clarity)
create policy "Admins can access all data" on public.admin_logs for all using ((select is_admin from users where id = auth.uid()));
create policy "Admins can access all data" on public.subscription_events for all using ((select is_admin from users where id = auth.uid()));

-- =============================================
-- 5. INITIAL DATA (Optional)
-- =============================================
-- You can add initial data here if needed, for example:
-- insert into public.plans (plan_id, name, price_cents, interval) values ('free', 'Free', 0, 'day');
-- insert into public.plans (plan_id, name, price_cents, interval, interval_count) values ('monthly', 'Monthly', 9700, 'month', 1);
